# Deep Dive: Backend Agents

## Overview

The backend logic is contained primarily in `backend/simple_agent.py`. Unlike complex agent frameworks (LangGraph, AutoGen), this project implements a **Functional Agent Pipeline**. It trades flexibility for reliability and predictability.

## State Management

State is managed by the `AgentState` class, which persists only for the duration of a single request.

```python
class AgentState:
    current_step: str      # Tracks pipeline progress
    logs: list             # Audit trail for UI
    sources: list          # Citations
    strategy: str          # Stage 1 output
    raw_data: str          # Stage 2 output
    insights: str          # Stage 3 output
    final_report: str      # Stage 4 output
```

## The "Agent" abstraction

In this codebase, an "Agent" is effectively a **Prompt + Context**. There are no separate classes for "Strategist" or "Analyst"; they are logical steps in the `perform_market_research_stream` generator.

### Prompts as Functions

Each step follows this pattern:
1.  **Prepare Context**: Format previous state (e.g., `strategy`) into a string.
2.  **Construct Prompt**: Inject context into a dedicated system prompt.
3.  **Inference**: Call `client.generate()`.
4.  **Update State**: Store result in `AgentState`.
5.  **Emit Event**: Yield SSE event to frontend.

## Error Handling Pipeline

The entire pipeline is wrapped in a high-level `try/except` block that catches any exception during the 4-step process and emits a distinct `error` SSE event. This ensures the frontend never hangs, even if the backend crashes mid-stream.

## Metric Collection

Prometheus metrics are deeply integrated:
- `active_research_requests` (Gauge)
- `research_reports_completed_total` (Counter)
- `research_duration_seconds` (Histogram)

This allows for production-grade monitoring of the agent's performance and latency.
